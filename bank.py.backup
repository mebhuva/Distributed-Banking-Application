import sys
import socket
import random
from threading import Thread
import pickle
import logging
import time
from threading import Lock
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)


sys.path.append('/home/vchaska1/protobuf/protobuf-3.5.1/python')
import bank_pb2

class Bank(object):

    branchName = ""
    branchBalance = 0
    branhList = []
    moneyTransfer = False
    snapshotList = []
    markerMsgChnlState = {}
    markerMsgBalance = {}
    critical_section_lock = Lock()


    def MoneyTransfer(self):
	#global branchBalance
	#global branhList
	#global moneyTransfer
	while True:
		print str(self.moneyTransfer) + str(self.branchBalance)
		if self.moneyTransfer == True and self.branchBalance>50:
			print "branch la balance va"+str(self.branchBalance)
			randomBranch = random.choice(self.branhList)
			print randomBranch.ip
			print randomBranch.port
			MoneyTransferMsg = bank_pb2.Transfer()
			MoneyTransferMsg.money = (int) ((self.branchBalance* random.randint(1,5)) /100)
			MoneyTransferMsg.src_branch = self.branchName
			with self.critical_section_lock:
				self.branchBalance = self.branchBalance - MoneyTransferMsg.money
			branchsocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            		branchsocket.connect((randomBranch.ip, randomBranch.port))
			branchMessage = bank_pb2.BranchMessage()
                	branchMessage.transfer.CopyFrom(MoneyTransferMsg)
			branchsocket.sendall(pickle.dumps(branchMessage))
			branchsocket.close()
			time.sleep(random.randrange(1, 5))

    def SendMarkers(self,snapshot_id):
	#global branhList
	#global moneyTransfer
	self.moneyTransfer  = False
	markerMessage = bank_pb2.Marker()
        markerMessage.snapshot_id = snapshot_id
	markerMessage.src_branch = self.branchName
        branchMessage = bank_pb2.BranchMessage()
        branchMessage.marker.CopyFrom(markerMessage)
	for branch in self.branhList:
        	markerSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                markerSocket.connect((branch.ip, branch.port))
                markerSocket.sendall(pickle.dumps(branchMessage))
                markerSocket.close()
	self.moneyTransfer  = True

    def bankhandle(self,data,branchName,clientsocket):
	self.branchName = branchName
	if data.HasField("init_branch") :
			self.branchBalance = data.init_branch.balance
			for branch in data.init_branch.all_branches:
                        	if branch.name != branchName:
                        		self.branhList.append(branch)
			print self.branhList
			#print "branchBalance...."+ str(self.branchBalance)
			self.moneyTransfer = True 
			#self.MoneyTransfer()
			time.sleep(4)
			thread = Thread(target = self.MoneyTransfer)
                	thread.daemon = True
                	thread.start()

	elif data.HasField("transfer") :
			if len(self.snapshotList) > 0 :
                        	snapshot_num = self.snapshotList [-1]
				print str(snapshot_num)+" snapshot number"
			print "snapshot number"
			print self.snapshotList
			print "marker msg balance "
			print self.markerMsgBalance
                        # check if incomming message needs to be recorded
                        if len(self.snapshotList) > 0 and self.markerMsgChnlState[ snapshot_num , data.transfer.src_branch ][0] == True and self.markerMsgBalance != 0:
				print "inside transfer snapshot"
				print data.transfer.money
				# Critical section, self.Account_Balance accessed by multiple threads
				with self.critical_section_lock:
                                       self.branchBalance = self.branchBalance + int(self.markerMsgChnlState[ snapshot_num , data.transfer.src_branch ][1])
                                self.markerMsgChnlState[ snapshot_num , data.transfer.src_branch ] = (True , int(data.transfer.money))
			else:
				#self.moneyTransfer = True
                		print "Now balance " + str(self.branchBalance) + " status " + str(self.moneyTransfer)
        	       	 	print "-----------------------------------------------"
	
        	        	# Critical section, self.Account_Balance accessed by multiple threads
        		        with self.critical_section_lock:
                 		       self.branchBalance = self.branchBalance + data.transfer.money
			print "branchBalance Updated to...."+ str(self.branchBalance)
			
		
	elif data.HasField("init_snapshot") :
			time.sleep(2)
			self.moneyTransfer  = False
                	#first record initial state
                	self.snapshotList.append(data.init_snapshot.snapshot_id)
                	self.markerMsgBalance[data.init_snapshot.snapshot_id] = self.branchBalance
                	for branch in self.branhList:
                        	# start recording on incomming channels
                        	self.markerMsgChnlState[ data.init_snapshot.snapshot_id , branch.name ] = (True , 0 )

                	# send marker's to all branch's
                	thread = Thread(target = self.SendMarkers(data.init_snapshot.snapshot_id))
                	thread.daemon = True
                	thread.start()
		
	elif data.HasField("marker") :
			self.moneyTransfer  = False
			if data.marker.snapshot_id not in self.snapshotList :
				self.snapshotList.append(data.marker.snapshot_id)
                        	self.markerMsgBalance[data.marker.snapshot_id] = self.branchBalance
				self.markerMsgChnlState[ data.marker.snapshot_id , data.marker.src_branch] = (False , 0 )
                        	for branch in self.branhList:
                                	self.markerMsgChnlState[ data.marker.snapshot_id , branchName ] = (True , 0 )
                        	self.SendMarkers(data.marker.snapshot_id)
                	else:
				print "printing channelstate"
				print self.markerMsgChnlState
                        	amount = self.markerMsgChnlState[data.marker.snapshot_id , data.marker.src_branch][1]
                              	self.markerMsgChnlState[data.marker.snapshot_id , data.marker.src_branch] = (False , amount )
			self.moneyTransfer  = True	
	elif data.HasField("retrieve_snapshot") :
			
			returnSnapshotMessage = bank_pb2.ReturnSnapshot.LocalSnapshot()
                	returnSnapshotMessage.snapshot_id = int(data.retrieve_snapshot.snapshot_id)
                	returnSnapshotMessage.balance = int(self.markerMsgBalance[data.retrieve_snapshot.snapshot_id])
                	for returnBranch in self.branhList:
				print self.markerMsgChnlState
                        	amount = self.markerMsgChnlState[data.retrieve_snapshot.snapshot_id , returnBranch.name][1]
				with self.critical_section_lock:
					self.branchBalance = self.branchBalance + amount 
                        	returnSnapshotMessage.channel_state.append(int(amount))

			branchMessage = bank_pb2.ReturnSnapshot()
                	branchMessage.local_snapshot.CopyFrom(returnSnapshotMessage)
			branchmessage = bank_pb2.BranchMessage()
			branchmessage.return_snapshot.CopyFrom(branchMessage)
			print "Returning Snapshot : ", branchmessage
			clientsocket.sendall(pickle.dumps(branchmessage))


if __name__ == '__main__':
	serversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	serversocket.bind((socket.gethostbyname(socket.gethostname()), int(sys.argv[2])))
	serversocket.listen(5)
	logger.debug("\nWaiting for connection... Listening on "+str(socket.gethostbyname(socket.gethostname())+":"+ sys.argv[2]))
	while 1:
        	(clientsocket, address) = serversocket.accept()
		data = pickle.loads(clientsocket.recv(1024))
		Bank().bankhandle(data,sys.argv[1],clientsocket)
		
			


